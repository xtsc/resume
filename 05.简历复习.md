#### cookie 和session 的区别详解
+ 通常请求和响应称为会话，所以有时也会说cookie和session是用来维持会话状态的。cookie是记录在客户端（浏览器）通过document.cookie进行读写。
```js
    // 读取
    console.log(document.cookie);//cookie 是以字符串形式存在的
    // 设置
    document.cookie = 'age=28';
```

+ cookie 默认生命周期为关闭浏览器，也可以进行设置
```js
    document.cookie = 'name=xiaoming; expires=' + (new Date('2017-12-31')).toUTCString();
```

+ cookie数据存放在客户的浏览器上，session数据放在服务器上。
+ cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
+ session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
+ 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

+ 要实现用户登录功能就必须要记录用户登录状态，配合cookie和session可以解决这个问题：
    - 用户输入正确用户名和密码后，将登录信息存储在cookie中，每次请求会将这个存储的信息发送到服务器，通过检测这个信息判断用户是否已登录，由于cookie是记录在客户端（浏览器）的，所以安全性不好。
    - 用户输入正确用户名和密码后，将登录信息存储在session中，由于session是存储在服务端，所以安全性很好，但是可能会带来另外一个问题，即服务器不能明确知道所存储的session信息是属于哪一个客户端（浏览器）。实际上是通过cookie来解决这个问题的，具体实现过程是服务器在存储session信息后，会生成一个唯一标识(sessionid)并将这个标识响应给浏览器，浏览器将这个标识(sessionid)存储在cookie中，当下次再请求时浏览器会将这个标识(sessionid)传递给服务端，服务端利用这个标识找到对应的session，进而判断用户的登录情况。

#### 利用cookie存储购物车内商品信息，完成购物车功能（添加、移除）

#### 主流浏览器兼容问题并作出相应处理

#### DOM结构

#### fullpage、lazyload

#### 预加载

#### 冒泡
+ Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。
+ 避免 Event Bubbling 的方式可以使用 event.stopPropagation() 或者 IE9 以下使用 event.cancelBubble = true。

#### 解释下 null 与 undefined 的区别
+ JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。

#### 闭包
+ 概念：
    - 闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
+ 用处：
    - 可以读取函数内部的变量
    - 让这些变量的值始终保持在内存中
+ 使用场景：
    - 使用闭包代替全局变量
    - 函数外或在其他函数中访问某一函数内部的参数
    - 
    - 在函数执行之前为函数提供只有在函数执行或引用时才能知道的具体参数
    - 为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点
    - 暂停执行
    - 包装相关功能
+ 使用闭包的注意点：
    - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除（手动将变量设置为 null，该变量将因为无引用被自动回收）。
    - 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

#### js垃圾回收机制

#### 面向对象的思想、核心
+ 面向对象，在基于对象的基础上增加了多态性。所谓多态，就是可以用统一的方法对不同的对象进行同样的操作。当然，这些对象不能完全不同，而需要有一些共性，只有存在了这些共性才可能用同样的方法去操作它们。
+ 面向对象的三个基本特征是：封装、继承、多态。
    - 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    - 继承：可以让某个类型的对象获得另一个类型的对象的属性的方法。通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。
    - 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。
    - 封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
+ 面向对象五大基本原则
    - 单一职责原则：一个类的功能要单一，不能包罗万象
    - 开放封闭原则：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的
    - 替换原则：子类应当可以替换父类并出现在父类能够出现的任何地方
    - 依赖原则：具体依赖抽象，上层依赖下层
    - 接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

#### JQuery框架

#### 原型链(构造函数创建对象的完整的原型链7个框，12条线)
+ 已知一个构造函数，该构造函数的实例，可以通过__proto__属性访问到原型中的属性和方法，后来发现原型之上还有原型，依次类推，包括数组、正则、函数等等所有的对象类型都可以通过查找一层层的__proto__属性都最终找到了某个对象(原型链的顶端),我们把这个查找过程称之为这个对象的原型链
+ 凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。普通对象没有prototype，但有\_\_proto__属性。
+ 对象的原型链
    - 结论1：
        + 对象字面量是Object构造函数的实例
        + 数组是Array构造函数的实例
        + 正则表达式是RegExp构造函数的实例
    - 结论2：
        + Object.prototype.\_\_proto__===null(原型链最顶端)
        + 自定义构造函数的默认的原型对象的__proto__指向Object.prototype
        + Array、RegExp、String、Number、Boolean这些函数的原型对象的__proto__都指向Object.prototype
+ 函数的原型链
    - 结论1：所有的函数都是Function的实例
        + 推论1：函数.\_\_proto__===Function.prototype
        + 推论2：Array.\_\_proto__===Function.prototype
        + 推论3：RegExp.\_\_proto__===Function.prototype
        + 推论4：Object.\_\_proto__===Function.prototype
        + 推论5：Function.\_\_proto__===Function.prototype
    - 结论2：Function.prototype.\_\_proto__===Object.prototype(原型链最顶端)
+ 区分对象类型
    - console.log(Object.prototype.toString.call(123)) //[object Number]
    - console.log(Object.prototype.toString.call('123')) //[object String]
    - console.log(Object.prototype.toString.call(undefined)) //[object Undefined]
    - console.log(Object.prototype.toString.call(true)) //[object Boolean]
    - console.log(Object.prototype.toString.call({})) //[object Object]
    - console.log(Object.prototype.toString.call([])) //[object Array]
    - console.log(Object.prototype.toString.call(function(){})) //[object Function]

#### JS创建对象的几种方式


#### HTML5和CSS3技术

#### zeptojs、swiperjs等框架

#### canvas，能对数据进行可视化处理

#### W3C标准

#### 流式布局和响应式布局
+ 静态布局即传统Web设计
    - 对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。
+ 自适应布局
    - 分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。
+ 流式布局
    - 页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。
+ 响应式布局
    - 页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。

#### http协议
+ http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议
+ 主要特点
    - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
    - 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
    - 无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
    - 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
    - 支持B/S及C/S模式。
+ http请求由三部分组成，分别是：请求行、请求头、请求主体
    - 请求行：用来说明请求类型,要访问的资源以及所使用的HTTP版本
    - 请求头：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
    - 空行:请求头后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行
    - 请求主体:也叫请求数据主体，可以添加任意的其他数据
+ HTTP响应也是由三个部分组成，分别是：状态行、响应头部、响应主体
    - 状态行：由HTTP协议版本号，状态码，状态消息三部分组成
    - 响应头部：用来说明客户端要使用的一些附加信息
    - 响应主体：服务器返回给客户端的文本信息
+ 状态码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:
    - 1xx：指示信息--表示请求已接收，继续处理
    - 2xx：成功--表示请求已被成功接收、理解、接受
    - 3xx：重定向--要完成请求必须进行更进一步的操作
    - 4xx：客户端错误--请求有语法错误或请求无法实现
    - 5xx：服务器端错误--服务器未能实现合法的请求
    - 常见状态码：
        + 200 OK                        //客户端请求成功
        + 400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
        + 401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
        + 403 Forbidden                 //服务器收到请求，但是拒绝提供服务
        + 404 Not Found                 //请求资源不存在，eg：输入了错误的URL
        + 500 Internal Server Error     //服务器发生不可预期的错误
        + 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
+ get请求：请求指定的页面信息，并返回实体主体
+ post请求：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
+ head请求：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
+ GET和POST的区别：
    - GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，POST方法是把提交的数据放在HTTP包的Body中
    - GET提交的数据大小有限制(因为浏览器对URL的长度有限制),而POST方法提交的数据没有限制
    - GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
    - GET方式提交数据，会带来安全问题

#### 三次握手、四次挥手

#### Ajax
+ 全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思
+ ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。
   1.使用CSS和XHTML来表示。
   2.使用DOM模型来交互和动态显示。
   3.使用XMLHttpRequest来和服务器进行异步通信。
   4.使用javascript来绑定和调用。
+ Ajax的原理简单来说是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。XMLHttpRequest是Ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
```js
    //ajax-get：
    //实例化XMLHttpRequest对象，与服务器通信，模拟http请求
    var xhr = new XMLHttpRequest();
    //请求行
    xhr.open('get','./get.php?key1=val1&key2=val2');
    //请求头
    xhr.setRequestHeader('content-Type','text/html');
    //请求主体
    xhr.send(null);
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
            console.log(xhr.responseText);
        }
    }

    //ajax-post：
    //实例化XMLHttpRequest对象，与服务器通信，模拟http请求
    var xhr = new XMLHttpRequest();
    //请求行
    xhr.open('post','./ajax-post.php');
    //请求头
    xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');
    //请求主体
    xhr.send('key1=val1&key2=val2');
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
            console.log(xhr.responseText);
        }
    }
```

+ Ajax的优点：
    - 无刷新更新数据:在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。
    - 异步与服务器通信：AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。
    - 前端和后端负载平衡：可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
    - 基于标准被广泛支持: 不需要下载插件或者小程序。
    - 界面与应用分离
+ Ajax的缺点
    - AJAX干掉了Back和History功能，即对浏览器机制的破坏
    - AJAX的安全问题
    - 对搜索引擎支持较弱
    - 破坏程序的异常处理机制
    - 违背URL和资源定位的初衷
    - 客户端过肥，太多客户端代码造成开发上的成本

#### 跨域
+ 同源策略是浏览器的一种安全策略，所谓同源是指域名，协议，端口完全相同。
+ 不同源则跨域，跨域访问会受到限制：不允许Javascrip进行DOM操作、不允许XMLHttpRequest（Ajax）请求
+ document.domain + iframe顶级域名相同的可以通过domain.name来解决，即同时设置 document.domain = 顶级域名（如example.com）
+ 用JSONP(JSON with Padding)解决跨域：
    - 原理：本质是利用了<script src=""></script>标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成
    - jQuery中跨域访问：dataType: 'jsonp' ，设置dataType值为jsonp即开启跨域访问
    - jsonp 可以指定服务端接收的参数的“key”值，默认为callback
    - jsonpCallback 可以指定相应的回调函数，默认自动生成
+ CORS：用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

#### less，sass
+ less语法：
    - 注释：`//`
    - 变量：@bgc:#daa520;
    - 混入
    ```css
        .header{
          padding:20px;
          .nav;
          .box;
        }
    ```

    - 函数
    ```css
        .br(@w,@c){
          border: @w solid @c;
          color:@c;
          background-color: @c;
        }
    ```
    
    - 计算、嵌套
    - 引入外部文件：`@import "var";`
+ 区别：
    - 编译环境不同，less需要引入less.js处理less代码输出css到浏览器，sass的安装需要ruby环境，在服务端处理
    - 变量符不同，less是@，sass是$
    - 引入外部css文件不同，都是@import，sass文件名应以_打头
    - sass支持条件语句，可以使用if、for循环
    - 工具库不同，sass有工具库Compass，less有UI组件库bootstrap

#### artTemplate 

#### require.js、sea.js优点（都是异步加载模块）
+ 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
+ js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 
+ 区别(对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同)：
    - AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
    - CMD推崇就近依赖，只有在用到某个模块的时候再去require
    - AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致
    - CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的
    - AMD用户体验好，因为没有延迟，依赖模块提前执行了
    - CMD性能好，因为只有用户需要的时候才执行

#### 五个需要回调函数的方法
+ every()：遍历数组中的每一项，有一项返回值为false，则结果为false，不改变原数组
```js
    var arr1 = [1,2,3,4,5,6];
    var bool2 = arr1.every(function (ele,index,arr) {  return ele > 2; });
    console.log(bool2);  //false
    console.log(arr1);    //[1,2,3,4,5,6]
```

+ some()：遍历数组中的每一项，有一项返回值为true，则结果为true，不改变原数组
```js
    var bool3 = arr1.some(function (ele,index,arr) {   return ele > 2;  });
    console.log(arr1);          //[1,2,3,4,5,6]
    console.log(bool3);         //true
```

+ forEach()：遍历数组，等同于for循环，改变原数组，返回值为undefined
```js
    var arr5 = [1,2,3,4,5,6];
    var arr3 = arr5.forEach(function (ele,index,arr) {
        arr[index] = ele*10;
    });
    console.log(arr5);     //[10,20,30,40,50,60]
    console.log(arr3);     //undefined
```

+ map()：返回执行该函数后的结果所组成的新数组，不改变原数组
```js
    var arr4 = arr1.map(function (ele,index,arr) { return ele*10; });
    console.log(arr1);      //[1,2,3,4,5,6]
    console.log(arr4);      //[10,20,30,40,50,60]
```

+ filter()：返回结果为true的项组成的新数组，不改变原数组
```js
    var arr2 = arr1.filter(function (ele,index,arr) {
        if(ele%2 === 0){  return true;  }
    });
    console.log(arr1);      //[1,2,3,4,5,6]
    console.log(arr2);      //[2,4,6]
```

#### 能熟练使用git、svn版本管理工具
+ CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。
+ 集中式版本控制系统，版本库是集中存放在中央服务器的，干活的时候，要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。必须联网才能工作，中央服务器要是出了问题，所有人都没法干活了。
+ 分布式版本控制系统每个人的电脑上都是一个完整的版本库，安全性要高很多，不需要联网。

#### 前端自动化工具Gulp，利用Gulp做代码的混淆压缩。

#### 熟悉Node.js 、Vue等框架

#### 了解后台语言PHP

#### 北京时代创信科技有限公司（2015/4——至今）
+ 法人：马洪宇
+ 北京市海淀区羊坊店路18号1幢7层724（地铁：海淀五路居A口）
+ 专业从事网站策划、网站设计、网站建设、seo优化、网络维护、移动互联网开发、软件开发、软件定制

#### 北京百川互动科技有限公司（2014/3——2015/3）
+ 创立于2003年
+ 北京市丰台区总部基地外环西路26号院67号楼B座5层
+ 公司核心业务：高端网站定制、品牌设计服务、移动端开发

#### IE和DOM事件流的区别
+ 事件流描述的是从页面中接受事件的顺序。
    1. 执行顺序不一样：
        - IE的事件流叫做事件冒泡，由事件的目标(event.srcElement)接受事件，然后逐级向上（例：下一个为包含event.srcElement的节点）传递事件,直到文档节点document。
        - 其他浏览器支持的另一种事件流：事件捕获，与事件冒泡正好相反，文档节点document先监听到事件，然后把事件逐级向下传递事件，直到目标节点event.target。
        - "DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。
    2. 参数不一样: 
        - element.attachEvent('onclick', callback);
        - element.addEventListener('click', callback, useCapture); 第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用
        - attachEvent()的第一个参数比addEventListener()的事件名多一个"on"，且没有第三个参数，因为IE事件模型只支持冒泡事件流; 
    3. 事件加不加on
    4. this指向问题: IE中事件处理程序处于全局作用域，其内的this会指向window;而DOM事件流的事件处理程序的作用域是元素作用域，其内的this指向其所属的元素
    5. 事件对象event的属性方法的差别
    ```js
           //IE                           DOM
    event.cancelBubble = true    event.stopPropagation() //停止冒泡
    event.returnValue = false    event.preventDefault() //取消事件传递后的默认处理
    event.srcEelement            event.target //事件目标
    ```

