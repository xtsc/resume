#### cookie 和session 的区别详解
+ 通常请求和响应称为会话，所以有时也会说cookie和session是用来维持会话状态的。cookie是记录在客户端（浏览器）通过document.cookie进行读写。
```js
    // 读取
    console.log(document.cookie);//cookie 是以字符串形式存在的
    // 设置
    document.cookie = 'age=28';
```

+ cookie 默认生命周期为关闭浏览器，也可以进行设置
```js
    document.cookie = 'name=xiaoming; expires=' + (new Date('2017-12-31')).toUTCString();
```

+ cookie数据存放在客户的浏览器上，session数据放在服务器上。
+ cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
+ session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
+ 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
+ 要实现用户登录功能就必须要记录用户登录状态，配合cookie和session可以解决这个问题：
    - 用户输入正确用户名和密码后，将登录信息存储在cookie中，每次请求会将这个存储的信息发送到服务器，通过检测这个信息判断用户是否已登录，由于cookie是记录在客户端（浏览器）的，所以安全性不好。
    - 用户输入正确用户名和密码后，将登录信息存储在session中，由于session是存储在服务端，所以安全性很好，但是可能会带来另外一个问题，即服务器不能明确知道所存储的session信息是属于哪一个客户端（浏览器）。实际上是通过cookie来解决这个问题的，具体实现过程是服务器在存储session信息后，会生成一个唯一标识(sessionid)并将这个标识响应给浏览器，浏览器将这个标识(sessionid)存储在cookie中，当下次再请求时浏览器会将这个标识(sessionid)传递给服务端，服务端利用这个标识找到对应的session，进而判断用户的登录情况。

#### sessionStorage、localStorage
+ sessionStorage：会话存储
    - 生命周期：页面关闭，数据丢失
    - 只能在同一窗口共享数据，存储大小为5M
+ localStorage：本地存储，存储在硬盘上
    - 生命周期：永久生效，除非手动删除
    - 多个窗口共享数据，存储大小为20M
+ sessionStorage 、localStorage 和 cookie 之间的区别
    - 共同点：都是保存在浏览器端，且同源的。
    - 区别：
        + cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
        + 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
        + 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
        + 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
        + Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。
        + Web Storage的api接口使用更方便。

#### 利用cookie存储购物车内商品信息，完成购物车功能（添加、移除）

#### 缓存技术
```html
    <!--将页面和缓存文件关联起来-->
    <html manifest="test.appcache">
```

#### 盒子模型
+ 标准 w3c 盒子模型
    - 范围包括margin、border、padding、content，width=content
+ ie 盒子模型
    - 范围包括margin、border、padding、content，width=content+padding+border
+ 在网页的顶部加上doctype声明，才算是选择了“标准 w3c 盒子模型”

#### 布局（左侧固定，右侧自适应）
```html
<style type="text/css">  
    .left{float:left;width:100px;height:50px;}  
    .right{margin-left:100px;width:auto;height:100px;}  
    
    .left{float: left;width:200px;}
    .right{overflow: hidden;}
    
    .left{position:absolute;left:0;top:0;width:100px;height:50px;} 
    .right{margin-left:100px;height:100px;}

    .content{display: table;}
    .left{display:table-cell;width:200px;}
    .right{display:table-cell;}
</style>
```

#### 布局（左侧、右侧固定，中间自适应）
```html
<style type="text/css">  
    .main{margin:0 200px; overflow: hidden;}
    .left{position:absolute; top:0; left: 0;width:200px;}
    .right{position:absolute;top:0; right:0; width:200px;}

    .main{position:absolute; top:0; left:200px; right:200px;}
    .left{float:left;width:200px;}
    .right{float:right;width:200px;}
</style>
<body>
    <div class="main"></div>
    <div class="left"></div>
    <div class="right"></div>
</body>
```

#### 主流浏览器兼容问题并作出相应处理

#### fetch
+ Fetch API 是基于 Promise 设计。对于 IE8+ 以上浏览器，在生产环境使用 Fetch 是可行的。
```js
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'json';
    xhr.onload = function() {
        console.log(xhr.response);
    };
    xhr.onerror = function() {
        console.log("Oops, error");
    };
    xhr.send();

    fetch(url).then(function(response) {
        return response.json();
    }).then(function(data) {
        console.log(data);
    }).catch(function(e) {
        console.log("Oops, error");
    });
```

#### 埋点（统计网站点击量）

#### git
+ git stash：把（未保存到暂存区前进行操作）当前工作现场“储藏”起来，现在，用git status查看工作区，就是干净的，因此可以放心地创建分支来修复bug。
+ git stash list：查看“储藏”列表
+ git stash apply：恢复“储藏”内容，但是stash内容并不删除
+ git stash pop：恢复“储藏”内容，并删除stash内容
+ git stash drop：删除stash内容

#### DOM结构

#### fullpage、lazyload

#### 冒泡
+ Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。
+ 避免 Event Bubbling 的方式可以使用 event.stopPropagation() 或者 IE9 以下使用 event.cancelBubble = true。

#### 解释下 null 与 undefined 的区别
+ JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。

#### 闭包
+ 概念：
    - 闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
+ 用处：
    - 可以读取函数内部的变量
    - 让这些变量的值始终保持在内存中
+ 使用场景：
    - 使用闭包代替全局变量
    - 函数外或在其他函数中访问某一函数内部的参数
    - 
    - 在函数执行之前为函数提供只有在函数执行或引用时才能知道的具体参数
    - 为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点
    - 暂停执行
    - 包装相关功能
+ 使用闭包的注意点：
    - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除（手动将变量设置为 null，该变量将因为无引用被自动回收）。
    - 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

#### js垃圾回收机制

#### 面向对象的思想、核心
+ 面向对象，在基于对象的基础上增加了多态性。所谓多态，就是可以用统一的方法对不同的对象进行同样的操作。当然，这些对象不能完全不同，而需要有一些共性，只有存在了这些共性才可能用同样的方法去操作它们。
+ 面向对象的三个基本特征是：封装、继承、多态。
    - 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    - 继承：可以让某个类型的对象获得另一个类型的对象的属性的方法。通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。
    - 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。
    - 封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
+ 面向对象五大基本原则
    - 单一职责原则：一个类的功能要单一，不能包罗万象
    - 开放封闭原则：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的
    - 替换原则：子类应当可以替换父类并出现在父类能够出现的任何地方
    - 依赖原则：具体依赖抽象，上层依赖下层
    - 接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

#### JQuery框架

#### 原型链(构造函数创建对象的完整的原型链7个框，12条线)
+ 已知一个构造函数，该构造函数的实例，可以通过__proto__属性访问到原型中的属性和方法，后来发现原型之上还有原型，依次类推，包括数组、正则、函数等等所有的对象类型都可以通过查找一层层的__proto__属性都最终找到了某个对象(原型链的顶端),我们把这个查找过程称之为这个对象的原型链
+ 凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。普通对象没有prototype，但有\_\_proto__属性。
+ 对象的原型链
    - 结论1：
        + 对象字面量是Object构造函数的实例
        + 数组是Array构造函数的实例
        + 正则表达式是RegExp构造函数的实例
    - 结论2：
        + Object.prototype.\_\_proto__===null(原型链最顶端)
        + 自定义构造函数的默认的原型对象的__proto__指向Object.prototype
        + Array、RegExp、String、Number、Boolean这些函数的原型对象的__proto__都指向Object.prototype
+ 函数的原型链
    - 结论1：所有的函数都是Function的实例
        + 推论1：函数.\_\_proto__===Function.prototype
        + 推论2：Array.\_\_proto__===Function.prototype
        + 推论3：RegExp.\_\_proto__===Function.prototype
        + 推论4：Object.\_\_proto__===Function.prototype
        + 推论5：Function.\_\_proto__===Function.prototype
    - 结论2：Function.prototype.\_\_proto__===Object.prototype(原型链最顶端)
+ 区分对象类型
    - console.log(Object.prototype.toString.call(123)) //[object Number]
    - console.log(Object.prototype.toString.call('123')) //[object String]
    - console.log(Object.prototype.toString.call(undefined)) //[object Undefined]
    - console.log(Object.prototype.toString.call(true)) //[object Boolean]
    - console.log(Object.prototype.toString.call({})) //[object Object]
    - console.log(Object.prototype.toString.call([])) //[object Array]
    - console.log(Object.prototype.toString.call(function(){})) //[object Function]

#### 同步加载、异步加载、延迟加载
+ 同步加载
    - 平常默认用的都是同步加载。如：`<script src="http://yourdomain.com/script.js"></script> `
　　- 同步模式又称阻塞模式，会阻止浏览器的后续处理，停止了后续的文件的解析、执行，如图像的渲染。浏览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作、重定向、输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来
+ 异步加载
```js
    (function() { 
        var s = document.createElement('script'); 
        s.type = 'text/javascript'; 
        s.async = true; 
        s.src = 'http://yourdomain.com/script.js'; 
        var x = document.getElementsByTagName('script')[0]; 
        x.parentNode.insertBefore(s, x); 
    })();
```

   - 异步加载也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。
在script标签内，用js创建一个script元素并插入到document中，这种就是异步加载js文件了。
+ 延迟加载（lazy loading）
    - 有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js的控制来异步加载。也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片
+ 预加载
    - 预加载是一种浏览器机制，使用浏览器空闲时间来预先下载或加载用户接下来很可能会浏览的页面或资源，当用户访问某个预加载的链接时，如果从缓存中获取资源，页面就得以快速呈现。

#### 内存溢出 out of memory：指程序在申请内存时，没有足够的内存空间供其使用，出现溢出
#### 内存泄露 memory leak：指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！
+ 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 
+ 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问，而系统也不能再次将它分配给需要的程序。分配的内存不足以放下数据项序列,称为内存溢出。
+ 内存泄漏的原因：
    - 未定义的变量会在全局对象创建一个新变量。在JS文件头部加上'use strict'，可以避免意外的全局变量。
    - 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。
    - 闭包可以维持函数内局部变量，使其得不到释放
+ 内存溢出的原因：
    - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据（采用分页的方式查询）；
    - 代码中存在死循环或递归调用或循环产生过多重复的对象实体；

#### RESTful API 设计指南
+ 协议：API与用户的通信协议，总是使用HTTPs协议。
+ 域名：尽量将API部署在专用域名之下`https://api.example.com`。如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。`https://example.org/api/`
+ 版本（Versioning）：将API的版本号放入URL`https://api.example.com/v1/`。另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。
+ 路径（Endpoint），"终点"（endpoint），表示API的具体网址。
    - 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。
    `https://api.example.com/v1/zoos`
    `https://api.example.com/v1/animals`
    `https://api.example.com/v1/employees`
+ HTTP动词：对于资源的具体操作类型，由HTTP动词表示。
    - 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
        + GET（SELECT）：从服务器取出资源（一项或多项）。
        `GET/zoos：列出所有动物园`
        `GET/zoos/ID：获取某个指定动物园的信息`
        `GET/zoos/ID/animals：列出某个指定动物园的所有动物`
        + POST（CREATE）：在服务器新建一个资源。
        `POST/zoos：新建一个动物园`
        + PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
        `PUT/zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）`
        + PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
        `PATCH/zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）`
        + DELETE（DELETE）：从服务器删除资源。
        `DELETE/zoos/ID：删除某个动物园`
        `DELETE/zoos/ID/animals/ID：删除某个指定动物园的指定动物`
    - 还有两个不常用的HTTP动词。
        + HEAD：获取资源的元数据。
        + OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。
+ 过滤信息（Filtering）：如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。
    - 下面是一些常见的参数。
        + ?limit=10：指定返回记录的数量。
        + ?offset=10：指定返回记录的开始位置。
        + ?page=2&per_page=100：指定第几页，以及每页的记录数。
        + ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
        + ?animal_type_id=1：指定筛选条件
        + 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。
+ 状态码（Status Codes）：服务器向用户返回的状态码和提示信息
    - 常见的有以下一些（方括号中是该状态码对应的HTTP动词）。
        + 200 OK - [GET]：服务器成功返回用户请求的数据。
        + 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
        + 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
        + 204 NO CONTENT - [DELETE]：用户删除数据成功。
        + 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
        + 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
        + 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
        + 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
        + 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
        + 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
        + 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
        + 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
+ 错误处理（Error handling）：如果状态码是4xx，就应该向用户返回出错信息。
    - 一般来说，返回的信息中将error作为键名，出错信息作为键值即可。`{ error: "Invalid API key" }`
+ 返回结果
    - GET /collection：返回资源对象的列表（数组）
    - GET /collection/resource：返回单个资源对象
    - POST /collection：返回新生成的资源对象
    - PUT /collection/resource：返回完整的资源对象
    - PATCH /collection/resource：返回完整的资源对象
    - DELETE /collection/resource：返回一个空文档
+ Hypermedia API
    - RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。
```js
{"link": {
  "rel":   "collection https://www.example.com/zoos",
  "href":  "https://api.example.com/zoos",
  "title": "List of zoos",
  "type":  "application/vnd.yourformat+json"
}}
```

+ 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。
+ 其他
    - API的身份认证应该使用OAuth 2.0框架(关于授权（authorization）的开放网络标准)。
    - 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。

#### JS创建对象的几种方式

#### HTML5和CSS3技术

#### zeptojs、swiperjs等框架

#### W3C标准
+ DOCTYPE是document type的简写，用来说明你用的XHTML或者HTML是什么版本。其中的DTD(例如xhtml1-transitional.dtd)叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。

#### CSS3有哪些新特性？
+ CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
+ 增加了更多的CSS选择器  多背景 rgba 
+ 在CSS3中唯一引入的伪元素是::selection.
+ 媒体查询，多栏布局
+ border-image

#### 对BFC规范的理解？
+ BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

#### 说说你对语义化的理解？
+ 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
+ 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
+ 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
+ 便于团队开发和维护，更具可读性。

#### Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
+ <!DOCTYPE>声明位于文档中的最前面，处于html标签之前。告知浏览器以何种模式来渲染文档。 
+ 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。
+ 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
+ DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

#### 你知道多少种Doctype文档类型？
+ 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
+ HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
+ XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。

#### HTML与XHTML——二者有什么区别
+ 所有的标记都必须要有一个相应的结束标记
+ 所有标签的元素和属性的名字都必须使用小写
+ 所有的XML标记都必须合理嵌套
+ 所有的属性必须用引号""括起来
+ 把所有<和&特殊符号用编码表示
+ 给所有属性赋一个值
+ 不要在注释内容中使“--”
+ 图片必须有说明文字

#### 常见兼容性问题
+ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.
+ 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}
+ 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）
    - #box{ float:left; width:10px; margin:0 0 0 100px;} 
    - 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
+ 渐进识别的方式，从总体中逐渐排除局部。 
+ 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 
+ 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
```css
  css
      .bb{
         background-color:#f1ee18;/*所有识别*/
        .background-color:#00deff\9; /*IE6、7、8识别*/
        +background-color:#a200ff;/*IE6、7识别*/
        _background-color:#1e0bd1;/*IE6识别*/ 
      } 
```

+ IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法：统一通过getAttribute()获取自定义属性。
+ IE下,event对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.解决方法:（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。
+ Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决
+ 超链接访问过后hover样式就不出现了,被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : link visited hover active
+ 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯`<doctype html>`
+ 上下margin重合问题，ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。

#### DOM操作——怎样添加、移除、移动、复制、创建和查找节点。
+ 创建新节点
    - createDocumentFragment()    //创建一个DOM片段
    - createElement()   //创建一个具体的元素
    - createTextNode()   //创建一个文本节点
+ 添加、移除、替换、插入
    - appendChild()
    - removeChild()
    - replaceChild()
    - insertBefore() //在已有的子节点前插入一个新的子节点
+ 查找
    - getElementsByTagName()    //通过标签名称
    - getElementsByName()      //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
    - getElementById()    //通过元素Id，唯一

#### js数组去重
```js
    Array.prototype.unique1 = function () {
      var n = []; //一个新的临时数组
      for (var i = 0; i < this.length; i++) //遍历当前数组
      {
        //如果当前数组的第i已经保存进了临时数组，那么跳过，
        //否则把当前项push到临时数组里面
        if (n.indexOf(this[i]) == -1) n.push(this[i]);
      }
      return n;
    }
```

#### easyui组件
+ BootStrap主要用于响应式开发，兼容不同设备的浏览器，但没有ajax组件，ajax开发依赖程序员纯手写。 
+ BootStrap一般用于互联网项目的用户可见模块的开发，例如主页、商品页面等
+ EasyUI是基于jQuery的UI插件集合体 
+ EasyUI主要用于Ajax的数据交互的效果开发，虽然样式上不如BootStrap绚丽，但EasyUI有着丰富的ajax功能组件，我们只需要调用组件就能完成丰富的ajax效果。EasyUI一般用于项目后台管理员相关模块的开发，例如：商品管理，订单管理等JAVAEE级别。
+ 如果着重展示效果，对ajax没有特殊要求，使用BootStrap。如果频繁使用AJAX进行数据交互，那么使用EasyUI更加方便。总之各有各的特点，用对地方就是好的。

#### 流式布局和响应式布局
+ 静态布局即传统Web设计
    - 对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。
+ 自适应布局
    - 分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。
+ 流式布局
    - 页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。
+ 响应式布局
    - 页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。

#### http协议
+ http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议
+ 主要特点
    - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
    - 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
    - 无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
    - 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
    - 支持B/S及C/S模式。
+ http请求由三部分组成，分别是：请求行、请求头、请求主体
    - 请求行：用来说明请求类型,要访问的资源以及所使用的HTTP版本
    - 请求头：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
    - 空行:请求头后面的空行是必须的,即使第四部分的请求数据为空，也必须有空行
    - 请求主体:也叫请求数据主体，可以添加任意的其他数据
+ HTTP响应也是由三个部分组成，分别是：状态行、响应头部、响应主体
    - 状态行：由HTTP协议版本号，状态码，状态消息三部分组成
    - 响应头部：用来说明客户端要使用的一些附加信息
    - 响应主体：服务器返回给客户端的文本信息
+ 状态码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:
    - 1xx：指示信息--表示请求已接收，继续处理
    - 2xx：成功--表示请求已被成功接收、理解、接受
    - 3xx：重定向--要完成请求必须进行更进一步的操作
    - 4xx：客户端错误--请求有语法错误或请求无法实现
    - 5xx：服务器端错误--服务器未能实现合法的请求
    - 常见状态码：
        + 200 OK                        //客户端请求成功
        + 203                          //表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确
        + 400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
        + 401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
        + 403 Forbidden                 //服务器收到请求，但是拒绝提供服务
        + 404 Not Found                 //请求资源不存在，eg：输入了错误的URL
        + 500 Internal Server Error     //服务器发生不可预期的错误
        + 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
+ get请求：请求指定的页面信息，并返回实体主体
+ post请求：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
+ head请求：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
+ GET和POST的区别：
    - GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，POST方法是把提交的数据放在HTTP包的Body中
    - GET提交的数据大小有限制(因为浏览器对URL的长度有限制),而POST方法提交的数据没有限制
    - GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
    - GET方式提交数据，会带来安全问题

#### 三次握手、四次挥手

#### Ajax
+ 全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思
+ ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。
   1.使用CSS和XHTML来表示。
   2.使用DOM模型来交互和动态显示。
   3.使用XMLHttpRequest来和服务器进行异步通信。
   4.使用javascript来绑定和调用。
+ Ajax的原理简单来说是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。XMLHttpRequest是Ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
```js
    //ajax-get：
    //实例化XMLHttpRequest对象，与服务器通信，模拟http请求
    var xhr = new XMLHttpRequest();
    //请求行
    xhr.open('get','./get.php?key1=val1&key2=val2');
    //请求头
    xhr.setRequestHeader('content-Type','text/html');
    //请求主体
    xhr.send(null);
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
            console.log(xhr.responseText);
        }
    }

    //ajax-post：
    //实例化XMLHttpRequest对象，与服务器通信，模拟http请求
    var xhr = new XMLHttpRequest();
    //请求行
    xhr.open('post','./ajax-post.php');
    //请求头
    xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');
    //请求主体
    xhr.send('key1=val1&key2=val2');
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
            console.log(xhr.responseText);
        }
    }
```

+ Ajax的优点：
    - 无刷新更新数据:在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。
    - 异步与服务器通信：AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。
    - 前端和后端负载平衡：可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
    - 基于标准被广泛支持: 不需要下载插件或者小程序。
    - 界面与应用分离
+ Ajax的缺点
    - AJAX干掉了Back和History功能，即对浏览器机制的破坏
    - AJAX的安全问题
    - 对搜索引擎支持较弱
    - 破坏程序的异常处理机制
    - 违背URL和资源定位的初衷
    - 客户端过肥，太多客户端代码造成开发上的成本

#### 优化网站性能的14条规则
1. 尽可能的减少 HTTP 的请求数(合并css，js、精灵图)
2. 启用Gzip压缩：把文件先在服务器端进行压缩，然后再传输
3. 将 CSS 样式放在页面的上方(浏览器在css全部传输完全之前不会去渲染任何的东西)
4. 将script放在页面最下面(防止script脚本的执行阻塞页面的下载、阻塞并行下载数量。)
+ HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个(IE只能为2个，其他浏览器如ff等都是默认设置为2个，不过新出的ie8可以达6个)。因此如果把图像文件分布到多台机器的话，可以达到超过2个的并行下载。但是当脚本文件下载时，浏览 器不会启动其他的并行下载
5. 避免使用 CSS 中的 Expressions
8. 将 JavaScript 和 CSS 独立成外部文件
9. 减少 DNS 查询(在域名和ip地址之间的转换工作称为域名解析，也称DNS查询)
10. 压缩 JavaScript 和 CSS (减少页面字节数)
11. 移除重复的脚本 [javascript]
12. 使 AJAX 缓存 

#### 跨域
+ 同源策略是浏览器的一种安全策略，所谓同源是指域名，协议，端口完全相同。
+ 不同源则跨域，跨域访问会受到限制：不允许Javascrip进行DOM操作、不允许XMLHttpRequest（Ajax）请求
+ document.domain + iframe顶级域名相同的可以通过domain.name来解决，即同时设置 document.domain = 顶级域名（如example.com）
+ 用JSONP(JSON with Padding)解决跨域：
    - 原理：本质是利用了<script src=""></script>标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成
    - jQuery中跨域访问：dataType: 'jsonp' ，设置dataType值为jsonp即开启跨域访问
    - jsonp 可以指定服务端接收的参数的“key”值，默认为callback
    - jsonpCallback 可以指定相应的回调函数，默认自动生成
+ CORS：用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。只要服务器实现了CORS接口，就可以跨源通信。

#### less，sass
+ less语法：
    - 注释：`//`
    - 变量：@bgc:#daa520;
    - 混入
    ```css
        .header{
          padding:20px;
          .nav;
          .box;
        }
    ```

    - 函数
    ```css
        .br(@w,@c){
          border: @w solid @c;
          color:@c;
          background-color: @c;
        }
    ```
    
    - 计算、嵌套
    - 引入外部文件：`@import "var";`
+ 区别：
    - 编译环境不同，less需要引入less.js处理less代码输出css到浏览器，sass的安装需要ruby环境，在服务端处理
    - 变量符不同，less是@，sass是$
    - 引入外部css文件不同，都是@import，sass文件名应以_打头
    - sass支持条件语句，可以使用if、for循环
    - 工具库不同，sass有工具库Compass，less有UI组件库bootstrap

#### artTemplate 

#### require.js、sea.js优点（都是异步加载模块）
+ 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
+ js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 
+ 区别(对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同)：
    - AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
    - CMD推崇就近依赖，只有在用到某个模块的时候再去require
    - AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致
    - CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的
    - AMD用户体验好，因为没有延迟，依赖模块提前执行了
    - CMD性能好，因为只有用户需要的时候才执行

#### 五个需要回调函数的方法
+ every()：遍历数组中的每一项，有一项返回值为false，则结果为false，不改变原数组
```js
    var arr1 = [1,2,3,4,5,6];
    var bool2 = arr1.every(function (ele,index,arr) {  return ele > 2; });
    console.log(bool2);  //false
    console.log(arr1);    //[1,2,3,4,5,6]
```

+ some()：遍历数组中的每一项，有一项返回值为true，则结果为true，不改变原数组
```js
    var bool3 = arr1.some(function (ele,index,arr) {   return ele > 2;  });
    console.log(arr1);          //[1,2,3,4,5,6]
    console.log(bool3);         //true
```

+ forEach()：遍历数组，等同于for循环，改变原数组，返回值为undefined
```js
    var arr5 = [1,2,3,4,5,6];
    var arr3 = arr5.forEach(function (ele,index,arr) {
        arr[index] = ele*10;
    });
    console.log(arr5);     //[10,20,30,40,50,60]
    console.log(arr3);     //undefined
```

+ map()：返回执行该函数后的结果所组成的新数组，不改变原数组
```js
    var arr4 = arr1.map(function (ele,index,arr) { return ele*10; });
    console.log(arr1);      //[1,2,3,4,5,6]
    console.log(arr4);      //[10,20,30,40,50,60]
```

+ filter()：返回结果为true的项组成的新数组，不改变原数组
```js
    var arr2 = arr1.filter(function (ele,index,arr) {
        if(ele%2 === 0){  return true;  }
    });
    console.log(arr1);      //[1,2,3,4,5,6]
    console.log(arr2);      //[2,4,6]
```

#### 能熟练使用git、svn版本管理工具
+ CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。
+ 集中式版本控制系统，版本库是集中存放在中央服务器的，干活的时候，要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。必须联网才能工作，中央服务器要是出了问题，所有人都没法干活了。
+ 分布式版本控制系统每个人的电脑上都是一个完整的版本库，安全性要高很多，不需要联网。

#### 前端自动化工具Gulp，利用Gulp做代码的混淆压缩。

#### 熟悉Node.js 、Vue等框架

#### 了解后台语言PHP

#### 北京时代创信科技有限公司（2015/4——至今）
+ 法人：马洪宇
+ 北京市海淀区羊坊店路18号1幢7层724（地铁：海淀五路居A口）
+ 专业从事网站策划、网站设计、网站建设、seo优化、网络维护、移动互联网开发、软件开发、软件定制

#### 北京百川互动科技有限公司（2014/3——2015/3）
+ 创立于2003年
+ 北京市丰台区总部基地外环西路26号院67号楼B座5层
+ 公司核心业务：高端网站定制、品牌设计服务、移动端开发

#### IE和DOM事件流的区别
+ 事件流描述的是从页面中接受事件的顺序。
    1. 执行顺序不一样：
        - IE的事件流叫做事件冒泡，由事件的目标(event.srcElement)接受事件，然后逐级向上（例：下一个为包含event.srcElement的节点）传递事件,直到文档节点document。
        - 其他浏览器支持的另一种事件流：事件捕获，与事件冒泡正好相反，文档节点document先监听到事件，然后把事件逐级向下传递事件，直到目标节点event.target。
        - "DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。
    2. 参数不一样: 
        - element.attachEvent('onclick', callback);
        - element.addEventListener('click', callback, useCapture); 第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用
        - attachEvent()的第一个参数比addEventListener()的事件名多一个"on"，且没有第三个参数，因为IE事件模型只支持冒泡事件流; 
    3. 事件加不加on
    4. this指向问题: IE中事件处理程序处于全局作用域，其内的this会指向window;而DOM事件流的事件处理程序的作用域是元素作用域，其内的this指向其所属的元素
    5. 事件对象event的属性方法的差别
    ```js
           //IE                           DOM
    event.cancelBubble = true    event.stopPropagation() //停止冒泡
    event.returnValue = false    event.preventDefault() //取消事件传递后的默认处理
    event.srcEelement            event.target //事件目标
    ```

