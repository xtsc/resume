#### 构造函数
+ 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。没有返回值，不能被直接调用，必须通过new运算符在创建对象时才会自动调用。

#### 五种继承
1.扩展继承
```js
    function Fn(){

    }
    Fn.prototype.say = function () {

    }
```

   + 给构造函数的prototype对象添加属性和方法，从而使该构造函数的每个实例都能访问到

2.替换继承
```js
    function Fn(){

    }
    Fn.prototype = {
        constructor:Fn,
        say:function(){},
        run:function(){}
    }
```

   + 重新设置了构造函数的prototype的值，让它指向一个全新的对象
   + 从此以后的实例都只能访问到这个对象中的属性和方法

3.混入继承(拷贝继承)
```js
    function Person(obj){
        //将obj中的属性遍历添加到this中
        for(var key in obj){
            //key是一个变量，该变量保存了每一次遍历obj获取到的属性的名称
            this[key] = obj[key];
        }
    }
    var p3=new Person({
        name:"李四",
        age:18,
        gender:"未知",
        grade:"小五",
        className:"5(3)班"
    });
```

   + 实现功能：将一个对象中的属性和方法分别遍历添加到另一个对象中
   + 实现方式：for...in...循环对象的每一个属性

4.原型式继承(经典继承)
```js
    var obj = {a:10,b:20,c:30};

    //ES5中实现了经典继承：Object.create()

    var o1 = create(obj);
    console.log(o1.__proto__===obj);//true
    console.log(o1.a);//10
    o1.a = 100;
    console.log(o1.a);//100，给o1自己添加了属性，再也访问不到obj中的a属性
```

   + 帮助用户创建一个新对象，让这个新对象可以访问到指定对象中的属性和方法
   + 新对象.\_\_proto__===指定对象
   + 原型式继承不需要关心构造函数，如果你要关心构造函数，那么就不要使用原型式继承
   + 替换继承是重新创建对象替换掉原来的原型，原型式继承是对象已经存在，将此对象赋给新对象，新对象的原型为原来存在的对象

5.构造函数继承
```js
    function Person(name,age,height){
        this.name = name;
        this.age = age;
        this.height = height;
    }
    function Student(name,age,height,number,grade){
        Person.call(this,name,age,height);
        //若采用构造函数调用，则this指向P1，
        //但是此处采用上下文调用，使this指向Student的实例
        //故Student的实例可以继承Person的属性和方法
        this.number = number;
        this.grade = grade;
    }
    var s1 = new Student("lisi",30,140,40,"大三");
```

   + 一个称为父类构造函数，一个称为子类构造函数
   + 如果父类构造函数中的代码完全适用于子类构造函数，就在子类构造函数中运用上下文模式借用父类构造函数，从而给子类的实例添加属性和方法

#### 四种调用
1.函数调用
```js
    function f1(){}
    f1();
```

   + this指向window，返回值由return语句决定

2.方法调用
```js
    var obj = {
        name:"张三",
        say:function(){}
    };
    obj.say();
```

   + this指向调用者，返回值由return语句决定

3.构造函数调用
```js
    function Fn(name){
        this.name = name;
    }
    var f1 = new Fn("zhangsan");
```

   + this指向构造函数的实例
   + 若无return语句，则默认返回this
   + 若有return语句，如果return了一个基本数据类型，则最终返回this
   + 若有return语句，如果return了一个对象，则最终返回这个对象

4.上下文调用
```js
    fn.call();//'上下文调用'
    fn.apply();//'上下文调用'
```

   + this由第一个参数决定，返回值由return语句决定
   + 第一种情况：实参为null或undefined，函数内部的this指向window
   + 第二种情况：实参为数字、字符串、布尔值，函数内部的this指向对应的基本包装类型的对象（Number、String、Boolean）
   + 第三种情况：实参为对象数据，函数内部的this指向该对象
   + call和apply的不同：
        - call方法的第一个实参表示this的指向，后面依次表示foo函数传递的参数，以逗号隔开
        - apply方法的第一个实参表示this的指向，第二个参数为数组，表示foo函数传递的实参

#### arguments.callee：指向当前函数本身